import {
  Animated,
  SafeAreaView,
  StyleSheet,
  Keyboard,
  View,
} from "react-native";
import { randomNumber, createLoginUrl } from "./utils";
import React, { useRef, useState, useEffect } from "react";
import WebView from "react-native-webview";
import { Dimensions } from "react-native";
import EventEmitter from "eventemitter3";

const eventEmitter = new EventEmitter();

const getResponse = (id) => {
  return new Promise((resolve, reject) => {
    eventEmitter.once(`${id}`, (params) => {
      if (params.error) {
        return reject(params.error);
      }
      return resolve(params.result);
    });
  });
};

const createRequest = ({ method, params = [] }) => {
  const id = randomNumber();
  return {
    type: "request",
    data: { id, method, params },
  };
};

function isJson(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }
  return true;
}

const Auth = React.forwardRef((props, ref) => {
  const { clientId, theme = "dark" } = props;
  const webViewRef = useRef(null);
  const [visible, setVisible] = useState(false);
  const deviceHeight = Dimensions.get("window").height;
  const keyboardHeight = useKeyboard();
  const bottom = useAnimatedBottom(visible, deviceHeight);
  const [loginState, setLoginState] = useState("not_connected");
  const [user, setUser] = useState({});
  const [url, setUrl] = useState("");
  const request = ({ method, params }) => {
    assertLoggedIn();
    return new Promise((resolve, reject) => {
      const r = createRequest({ method, params });
      sendRequest(r);
      getResponse(r.data.id).then(resolve, reject);
    });
  };

  const getUserInfo = () => {
    assertLoggedIn();
    return user;
  };

  const getUser = () => {
    return new Promise((resolve, reject) => {
      const request = createRequest({ method: "get_user_info", params: [] });
      getResponse(request.data.id).then((user) => {
        setUser(user);
        return resolve(user);
      }, reject);
      sendRequest(request);
    });
  };

  const getLoginState = () => {
    return loginState;
  };

  const sendTransaction = (params) => {
    assertLoggedIn();
    return new Promise((resolve, reject) => {
      if (!params.from) {
        params.from = user.address;
      }
      const request = createRequest({
        method: "eth_sendTransaction",
        params: [params],
      });
      getResponse(request.data.id).then(resolve, reject);
      sendRequest(request);
    });
  };

  const getAccount = () => {
    assertLoggedIn();
    return new Promise((resolve, reject) => {
      const request = createRequest({
        method: "eth_accounts",
        params: [],
      });
      getResponse(request.data.id).then(resolve, reject);
      sendRequest(request);
    });
  };

  const getBalance = () => {
    assertLoggedIn();
    return new Promise((resolve, reject) => {
      const request = createRequest({
        method: "eth_getBalance",
        params: [user.address, "latest"],
      });
      getResponse(request.data.id).then(resolve, reject);
      sendRequest(request);
    });
  };

  const messageHandler = (ev) => {
    if (isJson(ev.nativeEvent.data)) {
      const val = JSON.parse(ev.nativeEvent.data);
      if (val.type) {
        switch (val.type) {
          case "response": {
            if (val?.data?.id) {
              eventEmitter.emit(`${val.data.id}`, val.data);
            }
            break;
          }
          case "show_webview": {
            setVisible(true);
            break;
          }
          case "hide_webview": {
            setVisible(false);
            break;
          }
          case "login_complete": {
            getUser().then(() => {
              setLoginState("connected");
              setVisible(false);
              eventEmitter.emit(`login_complete`, {});
            });
            break;
          }
          case "logout_complete": {
            onLogout();
            eventEmitter.emit(`logout_complete`, {});
            break;
          }
        }
      }
    }
  };

  const logout = () => {
    assertLoggedIn();
    return new Promise((resolve, reject) => {
      const request = { type: "logout" };
      getResponse("logout_complete").then(resolve).catch(reject);
      sendRequest(request);
    });
  };

  const onLogout = () => {
    setUser({});
    setVisible(false);
    setLoginState("not_connected");
    setUrl("");
  };

  const showWallet = () => {
    if (loginState !== "not_connected") {
      setVisible(true);
    }
  };

  const hideWallet = () => {
    setVisible(false);
  };

  const loginWithSocial = (type) => {
    return new Promise((resolve, reject) => {
      if (loginState !== "connected") {
        const url = createLoginUrl({ clientId, kind: type, theme });
        setUrl(url);
        setLoginState("connecting");
        setVisible(true);
        getResponse("login_complete").then(resolve).catch(reject);
      } else {
        // TODO: Add error here
        return reject("User already logged in");
      }
    });
  };

  const loginWithOtp = (email) => {
    if (loginState !== "connected") {
      const url = createLoginUrl({
        clientId,
        email,
        kind: "passwordless",
        theme,
      });
      setUrl(url);
      setLoginState("connecting");
      setVisible(true);
      getResponse("login_complete").then(resolve).catch(reject);
    }
  };

  const assertLoggedIn = () => {
    if (loginState !== "connected") {
      throw new Error("user is not logged in");
    }
  };

  const sendRequest = async (data) => {
    if (webViewRef.current !== null) {
      webViewRef.current.injectJavaScript(
        `(function(){ window.dispatchEvent(new MessageEvent("message", {data: ${JSON.stringify(
          data
        )}}))})()`
      );
    }
  };
  React.useImperativeHandle(ref, () => ({
    showWallet,
    hideWallet,
    getLoginState,
    loginWithSocial,
    loginWithOtp,
    getUserInfo,
    logout,
    request,
    sendTransaction,
    getAccount,
    getBalance,
  }));

  const visibilityCss = {
    ...styles.modalContainer,
    maxHeight: "100%",
    height: deviceHeight - keyboardHeight,
    bottom: 0,
    // top: 0,
    translateY: bottom,
  };

  return (
    <Animated.View style={visibilityCss}>
      <SafeAreaView>
        <View style={{ ...styles.modalContent }}>
          {url ? (
            <WebView
              source={{
                uri: url,
              }}
              style={styles.webview}
              ref={webViewRef}
              onNavigationStateChange={(data) => {}}
              onMessage={messageHandler}
              javaScriptEnabled={true}
              userAgent="Mozilla/5.0 (Linux; Android 5.1.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/91.0.4472.164 Mobile Safari/535.19"
              originWhitelist={["https://*", "http://*", "file://*", "sms://*"]}
            />
          ) : null}
        </View>
      </SafeAreaView>
    </Animated.View>
  );
});

function useAnimatedBottom(show, height) {
  const animatedValue = React.useRef(new Animated.Value(0));

  const bottom = animatedValue.current.interpolate({
    inputRange: [0, 1],
    outputRange: [height, 0],
  });

  React.useEffect(() => {
    if (show) {
      Animated.spring(animatedValue.current, {
        toValue: 1,
        velocity: 8,
        tension: 8,
        friction: 8,
        useNativeDriver: true,
      }).start();
    } else {
      Animated.spring(animatedValue.current, {
        toValue: 0,
        velocity: 8,
        tension: 8,
        friction: 6,
        useNativeDriver: true,
      }).start();
    }
  }, [show]);

  return bottom;
}

export const useKeyboard = () => {
  const [keyboardHeight, setKeyboardHeight] = useState(0);

  useEffect(() => {
    function onKeyboardDidShow(e) {
      setKeyboardHeight(e.endCoordinates.height);
    }

    function onKeyboardDidHide() {
      setKeyboardHeight(0);
    }

    const showSubscription = Keyboard.addListener(
      "keyboardDidShow",
      onKeyboardDidShow
    );
    const hideSubscription = Keyboard.addListener(
      "keyboardDidHide",
      onKeyboardDidHide
    );
    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, []);

  return keyboardHeight;
};

const styles = StyleSheet.create({
  modalContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "transparent",
  },
  modalContent: {
    height: "100%",
    backgroundColor: "transparent",
  },
  webview: { backgroundColor: "transparent" },
});
export default Auth;
